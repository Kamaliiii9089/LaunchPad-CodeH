import axios from 'axios';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

class VulnerabilityService {
  constructor() {
    this.zapPath = process.env.OWASP_ZAP_PATH || 'zap.sh';
    this.zapPort = process.env.ZAP_DAEMON_PORT || 8090;
    this.zapApiKey = process.env.ZAP_API_KEY || '';
    this.zapBaseUrl = `http://localhost:${this.zapPort}`;
  }

  /**
   * Main vulnerability scanning method
   */
  async scanVulnerabilities(endpoints) {
    const results = {
      vulnerabilities: [],
      tools: {
        owaspZap: { used: false, duration: 0, alertsGenerated: 0 }
      },
      errors: []
    };

    try {
      logger.info(`Starting vulnerability scan for ${endpoints.length} endpoints`);

      // Start ZAP daemon if not running
      await this.ensureZapRunning();
      
      // Scan each endpoint
      for (const endpoint of endpoints) {
        try {
          const vulns = await this.scanEndpoint(endpoint);
          results.vulnerabilities.push(...vulns);
        } catch (error) {
          results.errors.push({
            message: `Scan failed for ${endpoint.url}: ${error.message}`,
            tool: 'owasp-zap'
          });
        }
      }

      results.tools.owaspZap.used = true;
      results.tools.owaspZap.alertsGenerated = results.vulnerabilities.length;

      // Add basic security checks
      const basicChecks = this.performBasicSecurityChecks(endpoints);
      results.vulnerabilities.push(...basicChecks);

      console.log(`âœ… Vulnerability scan completed: ${results.vulnerabilities.length} issues found`);
      return results;

    } catch (error) {
      results.errors.push({
        message: `Vulnerability scanning failed: ${error.message}`,
        tool: 'vulnerability-service'
      });
      return results;
    }
  }

  /**
   * Ensure OWASP ZAP daemon is running
   */
  async ensureZapRunning() {
    try {
      // Check if ZAP is already running
      const response = await axios.get(`${this.zapBaseUrl}/JSON/core/view/version/`, {
        timeout: 5000
      });
      
      if (response.data) {
        logger.info('OWASP ZAP is already running');
        return;
      }
    } catch (error) {
      // ZAP is not running, try to start it
      logger.info('Starting OWASP ZAP daemon...');

      try {
        // Start ZAP in daemon mode
        const zapCommand = `${this.zapPath} -daemon -port ${this.zapPort} -config api.disablekey=true`;
        exec(zapCommand, { detached: true });

        // Wait for ZAP to start
        let retries = 30;
        while (retries > 0) {
          try {
            await axios.get(`${this.zapBaseUrl}/JSON/core/view/version/`, { timeout: 2000 });
            logger.info('OWASP ZAP daemon started successfully');
            return;
          } catch (e) {
            await new Promise(resolve => setTimeout(resolve, 2000));
            retries--;
          }
        }

        throw new Error('Failed to start OWASP ZAP daemon');

      } catch (startError) {
        logger.warn('Could not start OWASP ZAP daemon', { error: startError.message });
        logger.info('Falling back to basic security checks only');
      }
    }
  }

  /**
   * Scan individual endpoint with OWASP ZAP
   */
  async scanEndpoint(endpoint) {
    const vulnerabilities = [];

    try {
      // Spider the endpoint to discover more URLs
      const spiderResponse = await axios.get(`${this.zapBaseUrl}/JSON/spider/action/scan/`, {
        params: {
          url: endpoint.url,
          recurse: true,
          inScopeOnly: false
        },
        timeout: 30000
      });

      const spiderId = spiderResponse.data.scan;
      
      // Wait for spider to complete (with timeout)
      let spiderProgress = 0;
      let attempts = 0;
      while (spiderProgress < 100 && attempts < 30) {
        const statusResponse = await axios.get(`${this.zapBaseUrl}/JSON/spider/view/status/`, {
          params: { scanId: spiderId }
        });
        spiderProgress = parseInt(statusResponse.data.status);
        await new Promise(resolve => setTimeout(resolve, 2000));
        attempts++;
      }

      // Run active scan
      const scanResponse = await axios.get(`${this.zapBaseUrl}/JSON/ascan/action/scan/`, {
        params: {
          url: endpoint.url,
          recurse: true,
          inScopeOnly: false
        },
        timeout: 30000
      });

      const scanId = scanResponse.data.scan;

      // Wait for scan to complete (with timeout)
      let scanProgress = 0;
      attempts = 0;
      while (scanProgress < 100 && attempts < 60) {
        const statusResponse = await axios.get(`${this.zapBaseUrl}/JSON/ascan/view/status/`, {
          params: { scanId: scanId }
        });
        scanProgress = parseInt(statusResponse.data.status);
        await new Promise(resolve => setTimeout(resolve, 3000));
        attempts++;
      }

      // Get alerts/vulnerabilities
      const alertsResponse = await axios.get(`${this.zapBaseUrl}/JSON/core/view/alerts/`, {
        params: { baseurl: endpoint.url }
      });

      const alerts = alertsResponse.data.alerts || [];
      
      for (const alert of alerts) {
        vulnerabilities.push({
          type: this.mapZapAlertToType(alert.pluginId),
          severity: this.mapZapRiskToSeverity(alert.risk),
          title: alert.name,
          description: alert.description,
          recommendation: alert.solution || 'Review and fix the identified security issue',
          cweId: alert.cweid,
          cvssScore: this.calculateCvssScore(alert.risk),
          evidence: {
            request: alert.param || '',
            response: alert.evidence || '',
            parameter: alert.param || '',
            location: alert.url || endpoint.url
          }
        });
      }

    } catch (error) {
      logger.warn(`ZAP scan failed for ${endpoint.url}`, { error: error.message });
      // Fall back to basic checks for this endpoint
      vulnerabilities.push(...this.performBasicSecurityChecks([endpoint]));
    }

    return vulnerabilities;
  }

  /**
   * Perform basic security checks without external tools
   */
  performBasicSecurityChecks(endpoints) {
    const vulnerabilities = [];

    for (const endpoint of endpoints) {
      // Check for HTTP vs HTTPS
      if (endpoint.url.startsWith('http://')) {
        vulnerabilities.push({
          type: 'insecure_protocol',
          severity: 'high',
          title: 'Insecure Protocol (HTTP)',
          description: `The endpoint ${endpoint.url} is using HTTP instead of HTTPS, which means data transmitted is not encrypted and can be intercepted.`,
          recommendation: 'Implement HTTPS/TLS encryption for all API endpoints to protect data in transit.',
          evidence: {
            location: endpoint.url
          }
        });
      }

      // Check for missing authentication
      if (endpoint.isPublic && endpoint.responseCode === 200) {
        vulnerabilities.push({
          type: 'no_authentication',
          severity: 'medium',
          title: 'No Authentication Required',
          description: `The endpoint ${endpoint.url} is publicly accessible without authentication, which may expose sensitive data.`,
          recommendation: 'Implement proper authentication mechanisms such as API keys, OAuth, or JWT tokens.',
          evidence: {
            location: endpoint.url,
            response: `HTTP ${endpoint.responseCode}`
          }
        });
      }

      // Check for CORS misconfigurations
      if (endpoint.headers && endpoint.headers['access-control-allow-origin'] === '*') {
        vulnerabilities.push({
          type: 'cors_misconfiguration',
          severity: 'medium',
          title: 'CORS Wildcard Configuration',
          description: `The endpoint ${endpoint.url} allows CORS requests from any origin (*), which can be exploited for cross-site attacks.`,
          recommendation: 'Configure CORS to allow only specific trusted origins instead of using wildcards.',
          evidence: {
            location: endpoint.url,
            response: 'Access-Control-Allow-Origin: *'
          }
        });
      }

      // Check for information disclosure in headers
      if (endpoint.headers) {
        const sensitiveHeaders = ['server', 'x-powered-by'];
        for (const header of sensitiveHeaders) {
          if (endpoint.headers[header]) {
            vulnerabilities.push({
              type: 'information_disclosure',
              severity: 'low',
              title: 'Information Disclosure in Headers',
              description: `The endpoint ${endpoint.url} reveals server information in HTTP headers, which can help attackers identify potential vulnerabilities.`,
              recommendation: 'Remove or obfuscate server information from HTTP response headers.',
              evidence: {
                location: endpoint.url,
                response: `${header}: ${endpoint.headers[header]}`
              }
            });
          }
        }
      }

      // Check for potential admin interfaces
      if (endpoint.path && (endpoint.path.includes('admin') || endpoint.path.includes('dashboard'))) {
        if (endpoint.responseCode < 400) {
          vulnerabilities.push({
            type: 'exposed_sensitive_data',
            severity: 'high',
            title: 'Exposed Administrative Interface',
            description: `The endpoint ${endpoint.url} appears to be an administrative interface that is publicly accessible.`,
            recommendation: 'Restrict access to administrative interfaces using IP whitelisting, VPN, or strong authentication.',
            evidence: {
              location: endpoint.url
            }
          });
        }
      }

      // Check for common API documentation endpoints
      const docPatterns = ['swagger', 'api-docs', 'openapi'];
      for (const pattern of docPatterns) {
        if (endpoint.path && endpoint.path.includes(pattern) && endpoint.responseCode === 200) {
          vulnerabilities.push({
            type: 'information_disclosure',
            severity: 'medium',
            title: 'Exposed API Documentation',
            description: `The endpoint ${endpoint.url} exposes API documentation publicly, which can reveal API structure and potentially sensitive endpoints to attackers.`,
            recommendation: 'Restrict access to API documentation or ensure it does not contain sensitive information.',
            evidence: {
              location: endpoint.url
            }
          });
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Map OWASP ZAP alert types to our vulnerability types
   */
  mapZapAlertToType(pluginId) {
    const mapping = {
      '10021': 'xss_injection',
      '40012': 'sql_injection',
      '10016': 'information_disclosure',
      '10017': 'cors_misconfiguration',
      '10035': 'insecure_protocol',
      '10098': 'outdated_version',
      '90001': 'insecure_protocol'
    };
    
    return mapping[pluginId] || 'other';
  }

  /**
   * Map OWASP ZAP risk levels to our severity levels
   */
  mapZapRiskToSeverity(risk) {
    const mapping = {
      'High': 'high',
      'Medium': 'medium',
      'Low': 'low',
      'Informational': 'low'
    };
    
    return mapping[risk] || 'medium';
  }

  /**
   * Calculate CVSS score based on severity
   */
  calculateCvssScore(risk) {
    const scores = {
      'High': 8.5,
      'Medium': 5.5,
      'Low': 2.5,
      'Informational': 0.0
    };
    
    return scores[risk] || 5.0;
  }
}

export default new VulnerabilityService();
